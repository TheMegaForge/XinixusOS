#include "include/memory.h"
#include <stddef.h>
//void init_pageMem(PageController* pager){
//    pager->mappedMBs = 6;
//    pager->base      = 0x1000;
//    pager->pml4Index = 0;
//    pager->pdptIndex = 0;
//    pager->pdtIndex  = 3;
//}
#define mask 0xFFFFF000ULL
SETUP_DATA void* page_pdpt = (void*)0x600000;
SETUP extern void display(uint64_t show);
SETUP_DATA PageController* krnlController;
SETUP extern uint64_t* assign_new_page(uint16_t base,uint16_t pml4Index,uint16_t pdptIndex,uint16_t pdtIndex,uint64_t store,uint64_t flags);
SETUP void Page2Mb(PageController* pager,user_ptr store,uint64_t flags){
    assign_new_page(pager->base,pager->pml4Index,pager->pdptIndex,pager->pdtIndex,store,3);
    register uint64_t baddr = (pager->pdtIndex*0x200000)+(pager->pdptIndex*0x40000000)+(pager->pml4Index*0x8000000000);
    for(int i = 0;i<512;i++){
        *((uint64_t*)store) = baddr|flags;
        baddr+=0x1000;
        store+=8;
    }
    pager->mappedMBs+=2;
    pager->pdtIndex++;
    if(pager->pdtIndex >= 512){
        pager->pdtIndex = 0;
        pager->pdptIndex++;
        uint64_t* ptr  = (uint64_t*)pager->base+(pager->pml4Index*8);
        uint64_t* sloc = (uint64_t*)(((*ptr) & mask)+(pager->pdptIndex*8));
        *sloc = (uint64_t)page_pdpt;
        *sloc|=PFLAG_PRESENT|PFLAG_WRITE;
        page_pdpt+=0x1000;
    }
}

SETUP void* unfoldMapped(PageController* pager){
    uint64_t addr = 0;
    addr+=pager->pml4Index*0x8000000000;
    addr+=pager->pdptIndex*0x40000000;
    addr+=pager->pdtIndex*0x200000;
    return (void*)addr;
}
typedef struct _pdref{
    uint64_t* pml4;
    uint16_t pdpt;
    uint16_t pdt;
    uint16_t pt;
    uint16_t offset;
}PageDeref;

#define CAST_FLAG(dst_type,addr,flag) (dst_type)((uint64_t)addr)|flag
#define SELF_DISPOSE(end_type,var,mask) var = (end_type)((uint64_t)var&mask)
SETUP extern uint64_t* acm2(uint64_t* pml4,uint16_t pdpt);
SETUP extern uint64_t* maskInc(user_ptr addr,uint64_t __mask__,uint64_t increments);
/*
  for address 0xFFFF00000000 -> 
  pml4 : 0x975000 (True)
  pdpt : 0x976000 (True)
  pdt  : 0x977000 (?)
  pt   : 0x66A000 (?)
  for address 0x2000 -> 
  pml4 : 0x2000   (True)
  pdpt : 0x3000   (True)
  pdt  : 0x4000   (True)
  pt   : 0x2000   (True)
 */
SETUP void* newVirtualPage(int mode,user_ptr* store,user_ptr physical,PageDeref* deref,uint64_t flags){
    if(mode == 0){//nothing is pre-stored
        *deref->pml4   = store[0];//stores pml4
        uint64_t* base = store[0];
        base = maskInc((void*)base,mask,deref->pdpt);
        *base = store[1];                   //stores pdpt

        base = maskInc((void*)*base,mask,deref->pdt);
        *base = store[2];                   //stores pdt



        base = maskInc((void*)*base,mask,deref->offset);
        physical = (user_ptr)((uint64_t)physical|flags);
        *base = physical;                   //stores physical
    }
}
SETUP extern uint64_t storeIfNull2Deref(uint64_t** toCheck,user_ptr store);
SETUP extern void pager__write__(uint64_t* base,uint16_t ptable,uint64_t flags,uint64_t physical);
SETUP void unfoldVirtual(uint64_t virtual,uint16_t* pml4,uint16_t* pdpt,uint16_t* pdt,uint16_t* pt,uint16_t* offset){
    *offset = virtual & 0xfff;//generated by microsoft edge copilot
    *pt = (virtual >> 12) & 0x1ff;
    *pdt = (virtual >> 21) & 0x1ff;
    *pdpt = (virtual >> 30) & 0x1ff;
    *pml4 = (virtual >> 39) & 0x1ff;
}
SETUP  void* VirtualPage4K(user_ptr* store,user_ptr virtual,user_ptr physical,uint64_t flags){
    register uint64_t __v  = (uint64_t)virtual;
    uint16_t pml4;
    uint16_t pdpt;
    uint16_t pdt;
    uint16_t pt;
    uint16_t offset;
    unfoldVirtual(__v,&pml4,&pdpt,&pdt,&pt,&offset);
    uint64_t __base = (uint64_t)krnlController->base;//0x1000
    __base+=(pml4*8);
    uint64_t* base = __base;
    store[0] = (void*)((uint64_t)store[0] | flags);
    store[1] = (void*)((uint64_t)store[1] | flags);
    store[2] = (void*)((uint64_t)store[2] | flags);
    /*
    TODO: implement new Page with this information
        pml4[0] -> 0x975000
        pdpt[0] -> 0x976000
        pdt[0]  -> 0x977000
    
    */
   if(*base == NVLL){
        PageDeref sInfo = {};
        uint64_t __pm = 0x1000;
        __pm+=(pml4*8);
        sInfo.pml4   = __pm;
        sInfo.pdpt   = pdpt;
        sInfo.pdt    = pdt;
        sInfo.pt     = pt;
        sInfo.offset = offset;
        return newVirtualPage(0,store,physical,&sInfo,flags);
    }
    base = (uint64_t*)(*base);
    base = (void*)((uint64_t)base & mask);
    base +=pdpt;
    if(*base == NVLL){
        PageDeref sInfo = {};
        uint64_t __pm = 0x1000;
        __pm+=(pml4*8);
        sInfo.pml4   = __pm;
        sInfo.pdpt   = pdpt;
        sInfo.pdt    = pdt;
        sInfo.pt     = pt;
        sInfo.offset = offset;
        return newVirtualPage(1,store,physical,&sInfo,flags);
    }
    base = (uint64_t*)(*base);
    base = (void*)((uint64_t)base & mask);
    base +=pdt;
    if(*base == NVLL){
        PageDeref sInfo = {};
        uint64_t __pm = 0x1000;
        __pm+=(pml4*8);
        sInfo.pml4   = __pm;
        sInfo.pdpt   = pdpt;
        sInfo.pdt    = pdt;
        sInfo.pt     = pt;
        sInfo.offset = offset;
        return newVirtualPage(2,store,physical,&sInfo,flags);
    }
    pager__write__(base,pt,flags,physical);
    return NULL;
}
SETUP void init_memInfo(MemoryController* controller){
    controller->available = 0;
    for(int i = 0;i<20;i++){
        controller->segments[i].type = 0;
        controller->segments[i].length = 0;
        controller->segments[i].base = 0;
    }
    register uint16_t segments = *(uint16_t*)0x996;
    register uint32_t* addr = (uint32_t*)0x780;
    for(uint8_t i = 0;i<segments;i++){
        if(*(addr+4) == 1){
            controller->available += *((uint64_t*)(addr+2));
        }
        if(*(addr+4) != 0){
            controller->segments[i].type   = *(addr+4);
            controller->segments[i].base   = *(uint64_t*)addr;
            controller->segments[i].length = *((uint64_t*)(addr+2));
        }
        addr+=6;
    }
}